class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int currentSum=0;
        int maxSum=Integer.MIN_VALUE;

        for (int i=0;i<n;i++){
            int temp=currentSum+nums[i];

            if(temp<nums[i]){
                currentSum=nums[i];
            } else {
                currentSum=temp;
            }
            if(maxSum<currentSum){
                maxSum=currentSum;
            }
            
        }
        return maxSum;
}
}

/* Approach

This uses Kadane’s Algorithm.
We iterate through the array and keep track of the current sum of subarray.
At each step, decide:
Continue the previous subarray (temp = currentSum + nums[i]), or
Start a new subarray from current element (nums[i]).
Keep updating the maximum sum found so far.

⏱ Time Complexity

O(n) → We go through the array once.

💾 Space Complexity

O(1) → Only variables used (currentSum, maxSum).

🎯 Pattern

Dynamic Programming (Kadane’s Algorithm)
Also falls under Sliding Window / Prefix Sum optimization idea.  */
