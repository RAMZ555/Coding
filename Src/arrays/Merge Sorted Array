class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        
    int i=m-1;
    int j=n-1;
    int k=m+n-1;

    while(i>=0 && j>=0){
       if( nums1[i]>nums2[j]){
        nums1[k--]=nums1[i--];
    }else {
        nums1[k--]=nums2[j--];    }
    }

        while(j>=0){
             nums1[k--]=nums2[j--];
        }
        }
    }


/* Approach

You are given two sorted arrays:
nums1 of size m+n (where first m elements are valid, and last n are empty slots for merging).
nums2 of size n.
The goal is to merge nums2 into nums1 in sorted order, in-place (without extra array).

Key Idea:
Start comparing from the end of both arrays (largest elements).

Use three pointers:
i = m-1 â†’ last valid element in nums1.
j = n-1 â†’ last element in nums2.
k = m+n-1 â†’ last position in nums1 (empty slot).
Place the bigger element at index k, then move the pointer.
Continue until one array is exhausted.
If any elements remain in nums2, copy them into nums1 (since nums1's leftover elements are already in correct place).

ðŸ”¹ Pattern
This follows the Two Pointer + Merge from End pattern.
Similar to the "merge step" in Merge Sort, but optimized to work in-place without extra space.

ðŸ”¹ Time Complexity
O(m+n) â†’ we scan both arrays once at most.

ðŸ”¹ Space Complexity
O(1) â†’ constant extra space, since we use only pointers (i, j, k). /*
